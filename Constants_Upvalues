local utilityLib = {}

local gc = getgc
local getInfoFunc = debug.getinfo or getinfo
local getUpvalueFunc = debug.getupvalue or getupvalue or getupval
local getConstantsFunc = debug.getconstants or getconstants or getconsts
local isXTypeClosure = is_synapse_function or issentinelclosure or is_protosmasher_closure or is_sirhurt_closure or istempleclosure or checkclosure
local isLocalClosure = islclosure or is_l_closure or (iscclosure and function(f) return not iscclosure(f) end)

assert(gc and getInfoFunc and getConstantsFunc and isXTypeClosure, "Exploit not supported")

local userdataPlaceholder = newproxy(false)

local function matchConstants(closure, constantList)
    if not constantList then
        return true
    end
    
    local constants = getConstantsFunc(closure)
    
    for index, value in pairs(constantList) do
        if constants[index] ~= value and value ~= userdataPlaceholder then
            return false
        end
    end
    
    return true
end

local function searchClosure(script, closureName, upvalueIndex, constantValues)
    for _, v in pairs(gc()) do
        local parentScript = rawget(getfenv(v), "script")

        if type(v) == "function" and 
            isLocalClosure(v) and 
            not isXTypeClosure(v) and 
            (
                (script == nil and parentScript.Parent == nil) or script == parentScript
            ) 
            and pcall(getUpvalueFunc, v, upvalueIndex)
        then
            if ((closureName and closureName ~= "Unnamed function") and getInfoFunc(v).name == closureName) and matchConstantValues(v, constantValues) then
                return v
            elseif (not closureName or closureName == "Unnamed function") and matchConstantValues(v, constantValues) then
                return v
            end
        end
    end
end

utilityLib.userdataPlaceholder = userdataPlaceholder
utilityLib.findClosureInScript = findClosureInScript

return utilityLib
